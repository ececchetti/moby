#lang s-exp "lang.ss"

(define def-prepend "g")
(define arg-prepend "a_")
(define local-prepend "l_")
(define struct-prepend "s")
(define empty-hash (make-immutable-hasheq empty))

(define-struct g-hold (dat gensym))

;; mod-symbol: string symbol string -> symbol
;; consumes a prepend string, an original symbol, and an append string
;; returns a new symbol with the prepend string prepended and the append string appended
(define (mod-symbol prepend symb append)
  (string->symbol (string-append prepend (symbol->string symb) append)))

;; get-struct-defs: (listof s-expr) -> (listof s-expr)
;; consumes a list of statements
;; returns all struct definitions in that list
(define (get-struct-defs expr-list)
  (filter (lambda (expr) (and (cons? expr)
                              (equal? (first expr) 'define-struct)))
          expr-list))

;; get-bound-ids: (listof s-expr) -> (listof s-expr)
;; consumes a list of statements
;; returns a list of all identifiers bound at top level
(define (get-bound-ids expr-list)
  (map second (filter (lambda (expr) (and (cons? expr)
                                          (equal? (first expr) 'define)))
                      expr-list)))

;; get-struct-procs: s-expr -> (listof symbol)
;; consumes a struct definition in abstract syntax
;; returns a list of procs generated by defining that struct
(define (get-struct-procs struct-def)
  (list* (second struct-def)
         (string->symbol (string-append "make-" (symbol->string (second struct-def))))
         (string->symbol (string-append (symbol->string (second struct-def)) "?"))
         (map (lambda (elt)
                (string->symbol (string-append (symbol->string (second struct-def))
                                               "-"
                                               (symbol->string elt))))
              (third struct-def))))

;; get-id-hash: s-expr number (hashof symbol . symbol) -> g-hold
;; consumes a symbolic expression, a gensym counter, and a hashtable of replacements
;; returns a g-hold containing a new hashtable and the new gensym
(define (get-id-hash expr gensym base-hash)
  (cond
    [(cons? expr)
     (cond
       [(equal? (first expr) 'define-struct)
        (local [(define orig-procs (get-struct-procs expr))
                (define new-procs
                  (get-struct-procs (list 'define-struct
                                          (mod-symbol (string-append struct-prepend
                                                                     (number->string gensym)
                                                                     "_")
                                                      (second expr)
                                                      "")
                                          (third expr))))]
          (make-g-hold (foldl (lambda (a-pair a-hash)
                                (hash-set a-hash (first a-pair) (second a-pair)))
                              base-hash
                              (map list orig-procs new-procs))
                       (add1 gensym)))]
       [(equal? (first expr) 'define)
        (local [(define name (if (cons? (second expr))
                                 (first (second expr))
                                 (second expr)))]
          (make-g-hold (hash-set base-hash
                                 name
                                 (mod-symbol (string-append def-prepend
                                                            (number->string gensym)
                                                            "_")
                                             name
                                             ""))
                       (add1 gensym)))]
       [else (foldl (lambda (an-expr return-hold)
                      (get-id-hash an-expr
                                   (g-hold-gensym return-hold)
                                   (g-hold-dat return-hold)))
                    (make-g-hold base-hash gensym)
                    expr)])]
    [else (make-g-hold base-hash gensym)]))

;; replace-ids: s-expr (hashof symbol . symbol) number -> g-hold
;; consumes a symbolic expression, a hash of replacements, and a current gensym counter
;; returns a g-hold where the data is the expression with identifiers in the hashtable
;;    replaced with what they map to, and where the gensym is the current gensym count
(define (replace-ids expr replacements gensym)
  (cond
    [(symbol? expr) (make-g-hold (if (false? (hash-ref replacements expr false))
                                     expr
                                     (hash-ref replacements expr false))
                                 gensym)]
    [(cons? expr)
     (cond
       [(or (equal? (first expr) 'define)
            (equal? (first expr) 'lambda))
        (local [(define new-args (if (equal? (first expr) 'lambda)
                                     (second expr)
                                     (if (cons? (second expr))
                                         (rest (second expr))
                                         empty)))
                (define new-replacements
                  (foldl (lambda (symb a-hash)
                           (hash-set a-hash
                                     symb
                                     (mod-symbol arg-prepend symb "")))
                         replacements
                         new-args))
                (define replaced-body (replace-ids (third expr) new-replacements gensym))]
          (make-g-hold (list (first expr)
                             (g-hold-dat (replace-ids (second expr) new-replacements gensym))
                             (g-hold-dat replaced-body))
                       (g-hold-gensym replaced-body)))]
       [(equal? (first expr) 'local)
        (local [(define new-replacements(get-id-hash (second expr) gensym replacements))
                (define replaced-body (replace-ids (third expr)
                                                   (g-hold-dat new-replacements)
                                                   (g-hold-gensym new-replacements)))]
          (make-g-hold (list 'local
                             (g-hold-dat (replace-ids (second expr)
                                                      (g-hold-dat new-replacements)
                                                      (g-hold-gensym new-replacements)))
                             (g-hold-dat replaced-body))
                       (g-hold-gensym replaced-body)))]
       [else (foldl (lambda (an-expr rest-hold)
                      (local [(define rec-hold (replace-ids an-expr
                                                            replacements
                                                            (g-hold-gensym rest-hold)))]
                        (make-g-hold (append (g-hold-dat rest-hold)
                                             (list (g-hold-dat rec-hold)))
                                     (g-hold-gensym rec-hold))))
                    (make-g-hold empty gensym)
                    expr)])]
    [else (make-g-hold expr gensym)]))

;; munge-identifiers: (listof s-expr) -> (listof s-expr)
;; consumes a list of toplevel expression
;; returns the same expression with all identifiers bound in that program munged
;;    using a gensym counter
(define (munge-identifiers expr)
  (local [(define id-hash (get-id-hash expr 0 empty-hash))]
    (g-hold-dat (replace-ids expr (g-hold-dat id-hash) (g-hold-gensym id-hash)))))

(provide munge-identifiers)

;; lift-struct-help: s-expr -> (listof s-expr)
;; cosumes a symbolic expression with munged identifiers
;; returns a two-element list where the first element is the original expression
;;    with all local struct definitions removed, and the second element is those definitions
(define (lift-struct-help expr)
  (cond
    [(cons? expr)
     (cond
       [(equal? (first expr) 'local)
        (local [(define struct-defs (filter (lambda (def) (equal? (first def)
                                                                  'define-struct))
                                            (second expr)))
                (define rest-defs (filter (lambda (def) (not (equal? (first def)
                                                                     'define-struct)))
                                          (second expr)))
                (define lifted-body (lift-struct-help (third expr)))]
          (list (if (empty? rest-defs)
                    (first lifted-body)
                    (list 'local
                      rest-defs
                      (first lifted-body)))
                (append struct-defs
                        (second lifted-body))))]
       [else (foldr (lambda (an-expr lifted-rest)
                      (local [(define lifted-expr (lift-struct-help an-expr))]
                        (list (cons (first lifted-expr)
                                    (first lifted-rest))
                              (append (second lifted-expr)
                                      (second lifted-rest)))))
                    (list empty empty)
                    expr)])]
    [else (list expr empty)]))

;; lift-local-structs: (listof s-expr) -> (listof s-expr)
;; consumes a symbolic expression and lifts all local struct definitions to toplevel
(define (lift-local-structs program)
  (foldr (lambda (an-expr rest-prog)
           (local [(define lifted-expr (lift-struct-help an-expr))]
             (append (second lifted-expr) (list (first lifted-expr)) rest-prog)))
         empty
         program))
